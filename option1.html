<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MIDI Excerpt Player (Loop + Keyboard)</title>

<!-- Tone.js and @tonejs/midi (open-source, CDN) -->
<script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>
<script src="https://unpkg.com/@tonejs/midi@2.0.28/build/Midi.js"></script>

<style>
  :root {
    --bg: #0b0e13;
    --panel: #141a22;
    --accent: #6dd3ff;
    --text: #e9eef5;
    --muted: #9fb3c8;
    --danger: #ff6b6b;
  }
  html, body {
    margin: 0; padding: 0; background: var(--bg); color: var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
  }
  .wrap {
    max-width: 980px; margin: 24px auto; padding: 16px;
  }
  .card {
    background: var(--panel); border-radius: 16px; padding: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.35);
  }
  h1 { font-size: 20px; margin: 0 0 10px; font-weight: 700; letter-spacing: .2px; }
  .subtitle { color: var(--muted); font-size: 14px; margin-bottom: 12px; }
  .controls {
    display: flex; gap: 10px; flex-wrap: wrap; align-items: center; margin: 10px 0 16px;
  }
  button, .toggle {
    background: #1c2430; color: var(--text); border: 1px solid #273142; border-radius: 10px;
    padding: 10px 14px; cursor: pointer; font-weight: 600;
  }
  button:hover, .toggle:hover { border-color: var(--accent); }
  .toggle.active { outline: 2px solid var(--accent); }
  .sliders {
    display: flex; gap: 18px; flex-wrap: wrap; align-items: center;
    padding: 10px; border: 1px dashed #273142; border-radius: 12px;
  }
  label { font-size: 12px; color: var(--muted); }
  input[type="range"] { width: 180px; }
  .row { display: flex; gap: 12px; align-items: center; }
  .kbdShell {
    background: #0b0f15; border-radius: 14px; padding: 12px; margin-top: 14px; border: 1px solid #1b2330;
  }
  .footer {
    margin-top: 10px; color: var(--muted); font-size: 12px;
  }
  .warn { color: var(--danger); }
  .hidden { display: none !important; }
  .small { font-size: 12px; color: var(--muted); }
  .grid {
    display: grid; grid-template-columns: 1fr; gap: 12px;
  }
  .btnPrimary {
    background: linear-gradient(180deg, #1f7aa6, #175a7a);
    border-color: #1b6f95;
  }
  .btnPrimary:hover { filter: brightness(1.05); }
  .fileName { color: var(--accent); font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
  canvas { width: 100%; height: auto; display: block; }
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>MIDI Excerpt Player</h1>
    <div class="subtitle">
      Loads <span class="fileName">excerpt1.mid</span> from this folder, loops playback, and lights an 88-key piano.
    </div>

    <div class="grid">
      <div class="controls">
        <button id="btnStart" class="btnPrimary">Start Audio & Load</button>
        <button id="btnPlay" disabled>Play</button>
        <button id="btnPause" disabled>Pause</button>
        <button id="btnStop" disabled>Stop</button>
        <button id="btnRew" disabled>⟲ Rewind</button>
        <button id="btnLoop" class="toggle active" disabled>Loop: On</button>
      </div>

      <div class="sliders">
        <div class="row">
          <label for="tempo">Tempo (%)</label>
          <input id="tempo" type="range" min="50" max="150" step="1" value="100" />
          <span id="tempoVal" class="small">100%</span>
        </div>
        <div class="row">
          <label for="vol">Volume (dB)</label>
          <input id="vol" type="range" min="-36" max="0" step="1" value="-6" />
          <span id="volVal" class="small">-6 dB</span>
        </div>
        <div class="row">
          <label for="rewTo">Rewind to (s)</label>
          <input id="rewTo" type="number" min="0" step="0.1" value="0" style="width:90px;" />
        </div>
      </div>

      <div class="kbdShell">
        <canvas id="piano" width="1800" height="260" aria-label="Piano keyboard visualization"></canvas>
      </div>

      <div id="status" class="footer">Ready. Click <b>Start Audio & Load</b> to initialize (required by browser).</div>
      <div id="error" class="footer warn hidden"></div>
    </div>
  </div>
</div>

<script>
(async function () {
  // ---------- Basic state ----------
  const statusEl = document.getElementById('status');
  const errorEl  = document.getElementById('error');
  const btnStart = document.getElementById('btnStart');
  const btnPlay  = document.getElementById('btnPlay');
  const btnPause = document.getElementById('btnPause');
  const btnStop  = document.getElementById('btnStop');
  const btnRew   = document.getElementById('btnRew');
  const btnLoop  = document.getElementById('btnLoop');
  const tempo    = document.getElementById('tempo');
  const tempoVal = document.getElementById('tempoVal');
  const vol      = document.getElementById('vol');
  const volVal   = document.getElementById('volVal');
  const rewTo    = document.getElementById('rewTo');
  const piano    = document.getElementById('piano');
  const ctx      = piano.getContext('2d');

  let midi, part, synth;
  let baseBpm = 120;
  let durationSec = 0;
  let loopEnabled = true;

  // ---------- Piano drawing ----------
  // MIDI 21 (A0) .. 108 (C8) => 88 keys
  const FIRST = 21, LAST = 108;
  const activeNotes = new Set();

  function isBlack(midi) {
    // pattern by pitch class (C=0..B=11)
    const pc = (midi % 12);
    return [1,3,6,8,10].includes(pc); // C#, D#, F#, G#, A#
  }

  function drawKeyboard() {
    const W = piano.width, H = piano.height;
    ctx.clearRect(0, 0, W, H);
    // Layout: compute white key count
    const keys = [];
    for (let m=FIRST; m<=LAST; m++) keys.push(m);
    const whites = keys.filter(k => !isBlack(k)).length;
    const whiteW = W / whites;
    const whiteH = H;

    // map midi->x for whites
    const whiteX = new Map();
    let xw = 0;
    for (let m=FIRST; m<=LAST; m++) {
      if (!isBlack(m)) {
        whiteX.set(m, xw);
        // Fill white key
        const isActive = activeNotes.has(m);
        ctx.fillStyle = isActive ? "#cdefff" : "#f7f9fc";
        ctx.fillRect(xw, 0, whiteW, whiteH);
        // border
        ctx.strokeStyle = "#c8d6e5";
        ctx.lineWidth = 1;
        ctx.strokeRect(xw, 0, whiteW, whiteH);
        xw += whiteW;
      }
    }

    // Draw black keys on top
    const blackW = whiteW * 0.62;
    const blackH = whiteH * 0.62;
    for (let m=FIRST; m<=LAST; m++) {
      if (isBlack(m)) {
        // black key sits between its surrounding whites
        // find previous white key x
        let prev = m - 1;
        while (prev >= FIRST && isBlack(prev)) prev--;
        let next = m + 1;
        while (next <= LAST && isBlack(next)) next++;

        if (!whiteX.has(prev) || !whiteX.has(next)) continue;
        const xPrev = whiteX.get(prev);
        const xNext = whiteX.get(next);
        const center = (xPrev + xNext + whiteW) / 2;
        const x = center - blackW / 2;

        const isActive = activeNotes.has(m);
        ctx.fillStyle = isActive ? "#74c0fc" : "#1d232b";
        ctx.fillRect(x, 0, blackW, blackH);
        ctx.strokeStyle = "#0f141b";
        ctx.strokeRect(x, 0, blackW, blackH);
      }
    }
  }

  function noteOn(midi) {
    activeNotes.add(midi);
    Tone.Draw.schedule(() => drawKeyboard(), Tone.now());
  }
  function noteOff(midi) {
    activeNotes.delete(midi);
    Tone.Draw.schedule(() => drawKeyboard(), Tone.now());
  }

  // Initial paint
  drawKeyboard();

  // ---------- Transport helpers ----------
  function setStatus(msg) { statusEl.textContent = msg; }
  function setError(msg)  { errorEl.textContent = msg; errorEl.classList.remove('hidden'); }
  function clearError()   { errorEl.classList.add('hidden'); errorEl.textContent = ""; }

  function enableTransport(enabled) {
    [btnPlay, btnPause, btnStop, btnRew, btnLoop].forEach(b => b.disabled = !enabled);
  }

  function applyTempoUI() {
    const pct = Number(tempo.value);
    tempoVal.textContent = pct + "%";
    const newBpm = Math.max(30, Math.min(300, baseBpm * (pct / 100)));
    Tone.Transport.bpm.value = newBpm;
  }

  function applyVolumeUI() {
    const db = Number(vol.value);
    volVal.textContent = db + " dB";
    Tone.Destination.volume.value = db;
  }

  // ---------- Build Part from MIDI ----------
  async function loadAndBuild() {
    clearError();
    setStatus("Loading excerpt1.mid …");

    // Fetch and parse MIDI
    try {
      midi = await Midi.fromUrl("./excerpt1.mid");
    } catch (e) {
      setError("Could not load excerpt1.mid. Make sure this HTML and the MIDI file are in the same folder and served over HTTP(S).");
      console.error(e);
      return;
    }

    // Base BPM & duration
    baseBpm = midi.header.tempos?.[0]?.bpm || 120;
    durationSec = midi.duration || 0;
    Tone.Transport.bpm.value = baseBpm;
    rewTo.value = 0;

    // Synth
    if (synth) synth.dispose();
    synth = new Tone.PolySynth(Tone.Synth, {
      oscillator: { type: "triangle" },
      envelope: { attack: 0.005, decay: 0.2, sustain: 0.2, release: 0.8 }
    }).toDestination();

    // Clear previous part
    if (part) {
      part.dispose();
      part = null;
    }

    // Collect all notes from all tracks
    const events = [];
    midi.tracks.forEach(t => {
      t.notes.forEach(n => {
        events.push({
          time: n.time,
          midi: n.midi,
          duration: n.duration,
          velocity: n.velocity
        });
      });
    });
    // Sort by time
    events.sort((a,b) => a.time - b.time);

    // Build Tone.Part
    part = new Tone.Part((time, ev) => {
      const freq = Tone.Frequency(ev.midi, "midi");
      synth.triggerAttackRelease(freq, ev.duration, time, ev.velocity);

      // Visualization: note on/off aligned to audio time
      Tone.Draw.schedule(() => noteOn(ev.midi), time);
      Tone.Draw.schedule(() => noteOff(ev.midi), time + ev.duration);
    }, events).start(0); // start at Transport 0

    // Loop setup
    Tone.Transport.loop = loopEnabled;
    Tone.Transport.loopStart = 0;
    Tone.Transport.loopEnd = durationSec + 0.01;

    // UI
    applyTempoUI();
    applyVolumeUI();
    enableTransport(true);
    btnLoop.classList.toggle("active", loopEnabled);
    btnLoop.textContent = `Loop: ${loopEnabled ? "On" : "Off"}`;

    setStatus(`Loaded. Duration: ${durationSec.toFixed(2)} s — Base tempo: ${baseBpm} BPM.`);
  }

  // ---------- Wire up controls ----------
  btnStart.addEventListener('click', async () => {
    try {
      await Tone.start(); // required by browsers (user gesture)
      btnStart.disabled = true;
      setStatus("Audio unlocked. Loading MIDI…");
      await loadAndBuild();
    } catch (e) {
      setError("Could not start audio context.");
      console.error(e);
    }
  });

  btnPlay.addEventListener('click', async () => {
    if (!part) return;
    await Tone.Transport.start("+0.01");
    setStatus("Playing…");
  });

  btnPause.addEventListener('click', async () => {
    await Tone.Transport.pause();
    setStatus("Paused.");
  });

  btnStop.addEventListener('click', async () => {
    await Tone.Transport.stop();
    activeNotes.clear(); drawKeyboard();
    setStatus("Stopped.");
  });

  btnRew.addEventListener('click', () => {
    const t = Math.max(0, Number(rewTo.value) || 0);
    Tone.Transport.seconds = Math.min(t, durationSec);
    setStatus(`Rewound to ${Tone.Transport.seconds.toFixed(2)} s.`);
  });

  btnLoop.addEventListener('click', () => {
    loopEnabled = !loopEnabled;
    Tone.Transport.loop = loopEnabled;
    btnLoop.classList.toggle("active", loopEnabled);
    btnLoop.textContent = `Loop: ${loopEnabled ? "On" : "Off"}`;
    setStatus(`Loop ${loopEnabled ? "enabled" : "disabled"}.`);
  });

  tempo.addEventListener('input', () => {
    applyTempoUI();
  });

  vol.addEventListener('input', () => {
    applyVolumeUI();
  });

  // Redraw on resize for crisp canvas
  function resizeCanvasForDPR() {
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const cssWidth = piano.clientWidth;
    const cssHeight = piano.clientHeight || 260;
    piano.width = Math.round(cssWidth * dpr);
    piano.height = Math.round(cssHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    drawKeyboard();
  }
  const ro = new ResizeObserver(resizeCanvasForDPR);
  ro.observe(piano);

  // Helpful: stop clears any stuck notes (e.g., page hide)
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      activeNotes.clear(); drawKeyboard();
    }
  });
})();
</script>
</body>
</html>
