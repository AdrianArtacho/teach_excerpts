<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Magenta Keyboard + OSMD (no audio)</title>

  <!-- Magenta core (NoteSequence parsing & helpers) -->
  <script defer src="https://cdn.jsdelivr.net/npm/@magenta/music@1.23.1/es6/core.js"></script>

  <!-- OSMD: MusicXML renderer -->
  <script defer src="https://cdn.jsdelivr.net/npm/opensheetmusicdisplay@1.8.8/build/opensheetmusicdisplay.min.js"></script>

  <!-- Simple on-screen keyboard web component -->
  <script defer src="https://cdn.jsdelivr.net/gh/micahscopes/all-around-keyboard/dist/all-around-keyboard.min.js"></script>

  <style>
    :root { --c1:#2f6fab; --c2:#f5f7fb; --c3:#222; --c4:#d7dbe4; }
    body{font-family:system-ui,Arial,sans-serif;background:var(--c2);color:var(--c3);padding:24px}
    h1{margin:0 0 12px;color:var(--c1)}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin:10px 0}
    .card{background:#fff;border:1px solid var(--c4);border-radius:12px;padding:16px;max-width:1000px}
    label{font-size:.95rem}
    input[type="range"]{width:220px}
    button{padding:8px 12px;border-radius:8px;border:1px solid var(--c4);background:#fff;cursor:pointer}
    #roll{width:100%;height:200px;border:1px solid var(--c4);border-radius:10px;background:#fff;margin:10px 0}
    all-around-keyboard{width:100%;height:170px;display:block;border:1px solid var(--c4);border-radius:10px}
    #osmd{background:#fff;border:1px solid var(--c4);border-radius:10px;padding:10px;margin-top:16px;overflow:auto}
    .small{font-size:.9rem;color:#555}
  </style>
</head>
<body>
  <h1>ðŸŽ¹ Magenta Keyboard + Notation (no audio)</h1>
  <div class="card">
    <div class="row">
      <label><strong>MIDI laden:</strong> <input id="midiFile" type="file" accept=".mid,.midi"></label>
      <label><strong>MusicXML laden:</strong> <input id="xmlFile" type="file" accept=".musicxml,.xml,.mxl"></label>
    </div>

    <div class="row">
      <button id="play">Play</button>
      <button id="stop">Stop</button>
      <label><input id="loop" type="checkbox"> Loop</label>
      <label><strong>Tempo:</strong> <span id="bpmVal">100</span> BPM</label>
      <input id="bpm" type="range" min="50" max="160" step="1" value="100">
    </div>

    <!-- Simple piano roll canvas (weâ€™ll draw it ourselves) -->
    <canvas id="roll"></canvas>

    <!-- Light-up keyboard -->
    <all-around-keyboard id="kb" octaves="2" width="900" depth="120"></all-around-keyboard>

    <!-- Notation (OSMD) -->
    <div id="osmd"><p class="small">Lade eine MusicXML-Datei, um die Notenschrift zu sehen.</p></div>

    <p class="small">Hinweis: Diese Seite spielt keinen Ton â€” sie visualisiert nur. Perfekt fÃ¼r Ãœben ohne Browser-Audio-Probleme.</p>
  </div>

  <script>
  document.addEventListener('DOMContentLoaded', () => {
    // --- UI refs
    const midiInput = document.getElementById('midiFile');
    const xmlInput  = document.getElementById('xmlFile');
    const playBtn   = document.getElementById('play');
    const stopBtn   = document.getElementById('stop');
    const loopCb    = document.getElementById('loop');
    const bpm       = document.getElementById('bpm');
    const bpmVal    = document.getElementById('bpmVal');
    const kb        = document.getElementById('kb');
    const rollCv    = document.getElementById('roll');
    const ctx       = rollCv.getContext('2d');

    // --- Keyboard config
    const LOWEST_PITCH = 60;                 // show from C4
    const OCTAVES      = parseInt(kb.getAttribute('octaves')) || 2;
    const TOTAL_KEYS   = 12 * OCTAVES;
    const toIdx = p => p - LOWEST_PITCH;

    // --- Playback state (timer-based, no audio)
    let seq = null;                // NoteSequence
    let notes = [];                // {p,s,e} array
    let total = 0;                 // seconds
    let playing = false;
    let startedAt = 0;             // perf.now() in seconds
    let t0 = 0;                    // paused offset
    let rafId = null;
    let lastLit = new Set();

    // --- Draw simple piano roll into canvas
    function drawRoll(){
      if (!seq) { ctx.clearRect(0,0,rollCv.width,rollCv.height); return; }
      const padding = 6;
      const W = rollCv.clientWidth, H = rollCv.clientHeight;
      // resize backing store for crispness
      if (rollCv.width !== W || rollCv.height !== H) { rollCv.width = W; rollCv.height = H; }
      ctx.clearRect(0,0,W,H);
      // axes
      ctx.fillStyle = '#f3f5fb';
      ctx.fillRect(0,0,W,H);
      // draw notes
      const secToX = s => padding + (W - 2*padding) * (s / Math.max(0.001,total));
      const keyH = (H - 2*padding) / TOTAL_KEYS;
      ctx.fillStyle = '#2f6fab';
      for (const n of notes) {
        const idx = toIdx(n.p);
        if (idx < 0 || idx >= TOTAL_KEYS) continue;
        const x = secToX(n.s), w = Math.max(2, secToX(n.e)-secToX(n.s));
        const y = H - padding - (idx+1)*keyH;
        ctx.fillRect(x, y, w, keyH - 1);
      }
    }

    // --- MIDI loading via Magenta
    async function loadMidi(file){
      const buf = await file.arrayBuffer();
      const ns  = mm.midiToSequenceProto(new Uint8Array(buf));
      // normalize & cache
      seq = ns;
      notes = (ns.notes || []).map(n => ({ p:n.pitch, s:n.startTime, e:n.endTime })).sort((a,b)=>a.s-b.s);
      total = ns.totalTime || (notes.length ? Math.max(...notes.map(n=>n.e)) : 0);
      t0 = 0;
      drawRoll();
    }

    // --- MusicXML/OSMD
    let osmd = null;
    async function loadXML(file){
      const buf = await file.arrayBuffer();
      if (!osmd) osmd = new opensheetmusicdisplay.OpenSheetMusicDisplay('osmd', { drawingParameters: 'compact' });
      await osmd.load(buf);
      osmd.render();
    }

    // --- Lighting helpers
    function dimAll(){ kb.keysDim(Array.from({length:TOTAL_KEYS}, (_,i)=>i)); lastLit.clear(); }
    function updateLights(t){
      const active = new Set();
      for (const n of notes) {
        if (t >= n.s && t < n.e) {
          const idx = toIdx(n.p);
          if (idx >= 0 && idx < TOTAL_KEYS) active.add(idx);
        }
      }
      const toLight = [], toDim = [];
      for (const i of active)   if (!lastLit.has(i)) toLight.push(i);
      for (const i of lastLit)  if (!active.has(i))  toDim.push(i);
      if (toLight.length) kb.keysLight(toLight);
      if (toDim.length)   kb.keysDim(toDim);
      lastLit = active;
    }

    // --- Transport (no sound): requestAnimationFrame loop
    const baseBPM = 100; // our slider reference
    const nowBPM  = () => Number(bpm.value);
    function currentTime(){
      if (!playing) return t0;
      const elapsed = (performance.now()/1000 - startedAt);
      const speed   = nowBPM() / baseBPM;
      return t0 + elapsed * speed;
    }
    function tick(){
      const t = currentTime();
      // loop
      if (loopCb.checked && total>0 && t >= total) {
        t0 = 0;
        startedAt = performance.now()/1000;
      }
      updateLights(Math.min(t,total));
      // progress marker on roll
      drawRoll();
      ctx.strokeStyle = '#e74c3c';
      const x = (rollCv.width - 12) * (Math.min(t,total) / Math.max(total,0.001)) + 6;
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,rollCv.height); ctx.stroke();

      rafId = requestAnimationFrame(tick);
    }

    function start(){
      if (!seq || playing) return;
      playing = true;
      startedAt = performance.now()/1000;
      rafId = requestAnimationFrame(tick);
    }
    function stop(){
      playing = false;
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
      t0 = 0;
      dimAll();
      drawRoll();
    }

    // --- UI wiring
    bpm.addEventListener('input', e => { bpmVal.textContent = e.target.value; });
    bpmVal.textContent = bpm.value;

    playBtn.addEventListener('click', start);
    stopBtn.addEventListener('click', stop);

    midiInput.addEventListener('change', e => {
      const f = e.target.files[0]; if (f) loadMidi(f).then(()=>{ dimAll(); drawRoll(); });
    });
    xmlInput.addEventListener('change', e => {
      const f = e.target.files[0]; if (f) loadXML(f);
    });

    // Optional: load a tiny built-in demo if user hasnâ€™t chosen a MIDI yet
    // fetch a public-domain 1-bar twinkle from Magenta repo:
    (async () => {
      try {
        const url = 'https://cdn.jsdelivr.net/gh/cifkao/html-midi-player@2b12128/twinkle_twinkle.mid';
        const resp = await fetch(url); const buf = await resp.arrayBuffer();
        const ns  = mm.midiToSequenceProto(new Uint8Array(buf));
        seq = ns;
        notes = (ns.notes || []).map(n => ({ p:n.pitch, s:n.startTime, e:n.endTime })).sort((a,b)=>a.s-b.s);
        total = ns.totalTime || (notes.length ? Math.max(...notes.map(n=>n.e)) : 0);
        drawRoll();
      } catch {}
    })();
  });
  </script>
</body>
</html>
