<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Visualizer – Keyboard + MusicXML (local)</title>

  <!-- IMPORTANT: serve this page over HTTP (not file://) so modules load -->
  <script type="module">
    // If you still want Magenta helpers for MIDI, expose them to window.mm.
    // It’s fine if these fail to load — MusicXML path works without them.
    try {
      const core = await import('./core.js');
      const midi = await import('./midi_io.js');
      window.mm = { ...core, ...midi };
    } catch (e) {
      console.warn('Magenta modules not loaded (ok if using MusicXML only).', e);
    }
  </script>

  <!-- Local copies -->
  <script defer src="./opensheetmusicdisplay.min.js"></script>
  <script defer src="./all-around-keyboard.min.js"></script>

  <style>
    :root { --c1:#2f6fab; --c2:#f5f7fb; --c3:#222; --c4:#d7dbe4; }
    * { box-sizing:border-box }
    body{font-family:system-ui,Arial,sans-serif;background:var(--c2);color:var(--c3);margin:0;padding:24px}
    h1{margin:0 0 12px;color:var(--c1)}
    .card{background:#fff;border:1px solid var(--c4);border-radius:12px;padding:16px;max-width:1000px;margin:0 auto}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin:10px 0}
    label{font-size:.95rem}
    input[type="range"]{width:220px}
    button{padding:8px 12px;border-radius:8px;border:1px solid var(--c4);background:#fff;cursor:pointer}
    button:disabled{opacity:.6;cursor:not-allowed}
    #roll{width:100%;height:200px;border:1px solid var(--c4);border-radius:10px;background:#fff;margin:10px 0}
    all-around-keyboard{width:100%;height:170px;display:block;border:1px solid var(--c4);border-radius:10px}
    #osmd{background:#fff;border:1px solid var(--c4);border-radius:10px;padding:10px;margin-top:16px;overflow:auto}
    #status{font:12px/1.4 ui-monospace,monospace;background:#fff;border:1px solid #e0e4ee;border-radius:8px;padding:8px;white-space:pre-wrap;max-height:160px;overflow:auto}
    .small{font-size:.9rem;color:#555}
  </style>
</head>
<body>
  <h1>🎹 Visualizer – Keyboard + Notation</h1>
  <div class="card">
    <div class="row">
      <label><strong>MIDI laden:</strong> <input id="midiFile" type="file" accept=".mid,.midi"></label>
      <label><strong>MusicXML laden:</strong> <input id="xmlFile" type="file" accept=".musicxml,.xml,.mxl"></label>
    </div>

    <div class="row">
      <button id="play" disabled>Play</button>
      <button id="stop" disabled>Stop</button>
      <label><input id="loop" type="checkbox"> Loop</label>
      <label><strong>Tempo:</strong> <span id="bpmVal">100</span> BPM</label>
      <input id="bpm" type="range" min="40" max="200" step="1" value="100">
    </div>

    <canvas id="roll"></canvas>
    <all-around-keyboard id="kb" octaves="3" width="900" depth="120"></all-around-keyboard>

    <div id="osmd"><p class="small">Lade eine MusicXML-Datei, um die Notenschrift zu sehen.</p></div>

    <h3>Status</h3>
    <div id="status"></div>
  </div>

  <script>
  const log = (...a)=>{ const el=document.getElementById('status'); el.textContent += a.join(' ') + '\n'; el.scrollTop=el.scrollHeight; };

  document.addEventListener('DOMContentLoaded', () => {
    // --- Globals / UI ---
    const baseBPM = 100;

    const midiInput = document.getElementById('midiFile');
    const xmlInput  = document.getElementById('xmlFile');
    const playBtn   = document.getElementById('play');
    const stopBtn   = document.getElementById('stop');
    const loopCb    = document.getElementById('loop');
    const bpm       = document.getElementById('bpm');
    const bpmVal    = document.getElementById('bpmVal');
    const kb        = document.getElementById('kb');
    const rollCv    = document.getElementById('roll');
    const ctx       = rollCv.getContext('2d');

    // Keyboard pitch window (expand if your piece goes higher/lower)
    const LOWEST_PITCH = 60; // C4
    const OCTAVES = parseInt(kb.getAttribute('octaves')) || 2;
    const TOTAL_KEYS = 12 * OCTAVES;
    const toIdx = p => p - LOWEST_PITCH;

    // Playback state
    let notes = [];   // {p: midi, s: sec, e: sec}
    let total = 0;
    let playing=false, startedAt=0, t0=0, rafId=null, lastLit=new Set();

    // ---------- WebAudio tiny synth (for key hits + simple playback) ----------
    const audio = { ctx:null, master:null, voices:new Map() };
    function audioInit(){
      if (audio.ctx) return;
      const Ctx = window.AudioContext || window.webkitAudioContext;
      audio.ctx = new Ctx();
      audio.master = audio.ctx.createGain();
      audio.master.gain.value = 0.15;
      audio.master.connect(audio.ctx.destination);
      log('🔊 AudioContext ready.');
    }
    function midiToFreq(m){ return 440 * Math.pow(2, (m - 69)/12); }
    function noteOn(midi, vel=0.8){
      if (!audio.ctx) audioInit();
      // Avoid duplicate voice
      if (audio.voices.has(midi)) return;
      const t = audio.ctx.currentTime;
      const osc = audio.ctx.createOscillator();
      const gain = audio.ctx.createGain();
      osc.type = 'sawtooth'; // simple but audible
      osc.frequency.value = midiToFreq(midi);
      gain.gain.setValueAtTime(0.0001, t);
      gain.gain.exponentialRampToValueAtTime(vel, t + 0.01);
      osc.connect(gain).connect(audio.master);
      osc.start();
      audio.voices.set(midi, {osc, gain});
    }
    function noteOff(midi){
      if (!audio.ctx) return;
      const v = audio.voices.get(midi);
      if (!v) return;
      const t = audio.ctx.currentTime;
      v.gain.gain.cancelScheduledValues(t);
      v.gain.gain.setTargetAtTime(0.0001, t, 0.03);
      v.osc.stop(t + 0.08);
      setTimeout(()=>audio.voices.delete(midi), 120);
    }

    // Hook the on-screen keyboard (support several event name variants)
    ['noteon','noteOn'].forEach(ev=>{
      kb.addEventListener(ev, e=>{
        const midi = e.detail?.midi ?? e.detail?.note ?? e.detail;
        if (typeof midi === 'number') noteOn(midi, 0.7);
      });
    });
    ['noteoff','noteOff'].forEach(ev=>{
      kb.addEventListener(ev, e=>{
        const midi = e.detail?.midi ?? e.detail?.note ?? e.detail;
        if (typeof midi === 'number') noteOff(midi);
      });
    });

    // ---------- Piano roll drawing ----------
    function drawRoll(){
      const pad=6, W=rollCv.clientWidth, H=rollCv.clientHeight;
      if (rollCv.width!==W||rollCv.height!==H){ rollCv.width=W; rollCv.height=H; }
      ctx.clearRect(0,0,W,H); ctx.fillStyle='#f3f5fb'; ctx.fillRect(0,0,W,H);
      if (!notes.length||total<=0) return;
      const secToX=s=>pad+(W-2*pad)*(s/total), keyH=(H-2*pad)/TOTAL_KEYS;
      ctx.fillStyle='#2f6fab';
      for(const n of notes){
        const i=toIdx(n.p); if(i<0||i>=TOTAL_KEYS) continue;
        const x=secToX(n.s), w=Math.max(2,secToX(n.e)-secToX(n.s)), y=H-pad-(i+1)*keyH;
        ctx.fillRect(x,y,w,keyH-1);
      }
    }
    function drawPlayhead(t){
      if(total<=0) return; const pad=6;
      const x=pad+(rollCv.width-2*pad)*(Math.min(t,total)/total);
      ctx.strokeStyle='#e74c3c'; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,rollCv.height); ctx.stroke();
    }

    // ---------- Lights + (optional) simple audio follow during playback ----------
    function dimAll(){ kb.keysDim(Array.from({length:TOTAL_KEYS},(_,i)=>i)); lastLit.clear(); }
    function updateLightsAndSound(t){
      const on=new Set();
      for(const n of notes){
        if(t>=n.s && t<n.e){
          const i=toIdx(n.p);
          if(i>=0&&i<TOTAL_KEYS) on.add(i);
        }
      }
      const light=[], dim=[];
      for(const i of on) if(!lastLit.has(i)) light.push(i);
      for(const i of lastLit) if(!on.has(i)) dim.push(i);
      if(light.length) kb.keysLight(light);
      if(dim.length) kb.keysDim(dim);
      // crude audio follow (turn on/off per frame transitions)
      for (const i of light) noteOn(LOWEST_PITCH + i, 0.25);
      for (const i of dim)  noteOff(LOWEST_PITCH + i);
      lastLit=on;
    }

    // ---------- Transport ----------
    const getBPM=()=>Number(bpm.value);
    bpm.addEventListener('input',e=>bpmVal.textContent=e.target.value); bpmVal.textContent=bpm.value;

    const nowTime=()=> !playing ? t0 : t0 + (performance.now()/1000 - startedAt) * (getBPM()/baseBPM);

    function tick(){
      const t=nowTime();
      if(loopCb.checked && total>0 && t>=total){
        t0=0; startedAt=performance.now()/1000;
      }
      drawRoll();
      const tt = Math.min(t,total);
      drawPlayhead(tt);
      updateLightsAndSound(tt);
      rafId=requestAnimationFrame(tick);
    }
    function start(){
      if(!notes.length||playing) { if(!notes.length) log('⚠️ Keine Noten geladen.'); return; }
      // Resume audio on user action (autoplay policies)
      audioInit(); audio.ctx.resume?.();
      playing=true; startedAt=performance.now()/1000; rafId=requestAnimationFrame(tick);
    }
    function stop(){
      playing=false; if(rafId) cancelAnimationFrame(rafId); rafId=null; t0=0;
      // turn off any sounding voices
      for (const [m] of audio.voices) noteOff(m);
      dimAll(); drawRoll();
    }

    // ---------- MIDI (optional; requires mm.midiToNoteSequence/Proto) ----------
    async function parseMidi(file){
      if(!window.mm) throw new Error('Magenta (mm) nicht geladen.');
      const bytes = new Uint8Array(await file.arrayBuffer());
      const fn = mm?.midiToNoteSequence || mm?.midiToSequenceProto;
      if(typeof fn!=='function') throw new Error('Kein MIDI-Parser in der lokalen Magenta-Bundle exportiert.');
      return await Promise.resolve(fn(bytes));
    }
    async function loadMidi(file){
      try{
        const ns = await parseMidi(file);
        notes = (ns.notes||[]).map(n=>({p:n.pitch,s:n.startTime,e:n.endTime})).sort((a,b)=>a.s-b.s);
        total = ns.totalTime || (notes.length?Math.max(...notes.map(n=>n.e)):0);
        t0=0; drawRoll(); dimAll();
        playBtn.disabled = stopBtn.disabled = notes.length===0;
        log('MIDI geladen:', file.name, `| Noten: ${notes.length} | Dauer: ${total.toFixed(2)}s`);
      }catch(err){
        console.error(err); log('MIDI-Fehler:', err?.message||err);
        alert('MIDI konnte nicht geladen werden. Probier MusicXML.\n\nDetails: '+(err?.message||err));
      }
    }

    // ---------- MusicXML via OSMD ----------
    let osmd=null;

    // Robust extractor: try cursor; if empty, fall back to sheet walk.
    async function extractNotesFromXML() {
      if (!osmd) throw new Error('OSMD nicht initialisiert');
      const secPerQuarterAtBase = 60 / baseBPM;
      const collected = [];

      // Try cursor first
      try {
        const cursor = osmd.cursor;
        cursor.reset();
        cursor.show();

        // Some OSMD builds have endReached (lowercase); normalize:
        const endReached = () => cursor.iterator?.EndReached ?? cursor.iterator?.endReached ?? false;

        let safety = 0, maxSteps = 200000; // guard against infinite loops
        while (!endReached() && safety++ < maxSteps) {
          const tWhole = cursor.iterator?.CurrentTimeStamp?.RealValue ?? cursor.iterator?.CurrentTimeStamp?.realValue ?? 0;
          const startSec = (tWhole * 4) * secPerQuarterAtBase;

          const gnotes = cursor.NotesUnderCursor?.() || [];
          for (const gn of gnotes) {
            const sn = gn.sourceNote;
            if (!sn || sn.IsRest) continue;
            const lenWhole = sn.Length?.RealValue ?? sn.length?.realValue ?? 0;
            const endSec = startSec + (lenWhole * 4) * secPerQuarterAtBase;

            // MIDI pitch extraction across versions
            const pitchMidi =
              sn.Pitch?.getHalfTone?.() ??
              sn.Pitch?.HalfTone ??
              sn.halfTone ??
              null;

            if (pitchMidi != null && endSec > startSec) {
              collected.push({ p: pitchMidi, s: startSec, e: endSec });
            }
          }
          cursor.next();
        }
        cursor.hide();
      } catch (e) {
        console.warn('Cursor extraction failed, will try sheet-walk:', e);
      }

      // Fallback: walk the sheet model (voices -> notes)
      if (collected.length === 0) {
        try {
          const sheet = osmd.sheet;
          const srcMeasures = sheet?.SourceMeasures || sheet?.sourceMeasures || [];
          for (const sm of srcMeasures) {
            const staffEntries = sm?.VerticalSourceStaffEntryContainers || sm?.verticalSourceStaffEntryContainers || [];
            for (const cont of staffEntries) {
              const tWhole = cont?.Timestamp?.RealValue ?? cont?.timestamp?.realValue ?? 0;
              const startSec = (tWhole * 4) * secPerQuarterAtBase;
              const entries = cont?.StaffEntries || cont?.staffEntries || [];
              for (const se of entries) {
                const voices = se?.VoiceEntries || se?.voiceEntries || [];
                for (const ve of voices) {
                  const notesArr = ve?.Notes || ve?.notes || [];
                  for (const n of notesArr) {
                    if (n?.isRest) continue;
                    const pitchMidi =
                      n?.Pitch?.getHalfTone?.() ??
                      n?.Pitch?.HalfTone ??
                      n?.halfTone ??
                      null;
                    const lenWhole = n?.Length?.RealValue ?? n?.length?.realValue ?? 0;
                    const endSec = startSec + (lenWhole * 4) * secPerQuarterAtBase;
                    if (pitchMidi != null && endSec > startSec) {
                      collected.push({ p: pitchMidi, s: startSec, e: endSec });
                    }
                  }
                }
              }
            }
          }
          if (collected.length) {
            log(`ℹ️ Fallback-Extraktion erfolgreich: ${collected.length} Noten.`);
          }
        } catch (e2) {
          console.error('Sheet-walk extraction failed:', e2);
        }
      }

      notes = collected.sort((a, b) => a.s - b.s);
      total = notes.length ? Math.max(...notes.map(n => n.e)) : 0;
      t0 = 0;

      if (!notes.length) {
        log('⚠️ Keine Noten gefunden. Enthält die Datei echte Notenköpfe (keine reinen Pausen/Layouts)?');
      } else {
        const low = notes.reduce((m, n) => Math.min(m, n.p), 128);
        const high = notes.reduce((m, n) => Math.max(m, n.p), 0);
        const lowIdx = low - LOWEST_PITCH, highIdx = high - LOWEST_PITCH;
        if (lowIdx < 0 || highIdx >= TOTAL_KEYS) {
          log(`⚠️ Tonumfang ${low}–${high} (MIDI). Tastatur zeigt ${LOWEST_PITCH}–${LOWEST_PITCH + TOTAL_KEYS - 1}.`);
        }
      }
    }

    async function loadXML(file){
      try{
        if(!window.opensheetmusicdisplay) throw new Error('OSMD Script nicht geladen.');
        if(!osmd) osmd=new opensheetmusicdisplay.OpenSheetMusicDisplay('osmd',{drawingParameters:'compact'});
        const ext=file.name.toLowerCase().split('.').pop();
        if(ext==='mxl'){ await osmd.load(await file.arrayBuffer()); }
        else { await osmd.load(await file.text()); }
        await osmd.render();
        log('MusicXML gerendert.');

        await extractNotesFromXML();

        dimAll();
        drawRoll();
        playBtn.disabled = notes.length === 0;
        stopBtn.disabled = notes.length === 0;

        log('MusicXML geladen:', file.name, `| Noten: ${notes.length} | Dauer: ${total.toFixed(2)}s`);
      }catch(err){
        console.error(err);
        log('OSMD Fehler:', err?.message||err);
        alert('Konnte MusicXML nicht laden/analysieren. Datei muss <score-partwise> oder <score-timewise> enthalten.');
      }
    }

    // ---------- Wiring ----------
    midiInput.addEventListener('change', e => {
      const f=e.target.files[0]; if(!f) return;
      const ext=f.name.toLowerCase().split('.').pop();
      if(ext==='mid'||ext==='midi') loadMidi(f);
      else alert('Bitte eine MIDI-Datei (.mid/.midi) wählen.');
    });
    xmlInput.addEventListener('change', e => {
      const f=e.target.files[0]; if(!f) return;
      const ext=f.name.toLowerCase().split('.').pop();
      if(['xml','musicxml','mxl'].includes(ext)) loadXML(f);
      else alert('Bitte eine MusicXML-Datei (.xml/.musicxml/.mxl) wählen.');
    });

    playBtn.addEventListener('click', start);
    stopBtn.addEventListener('click', stop);

    // Debug
    setTimeout(()=>{
      const okModule = !!window.mm;
      log('HTTP-Served?', location.protocol.startsWith('http') ? 'ja' : 'nein (bitte lokalen Server nutzen)');
      log('Magenta geladen?', okModule, '| midiToNoteSequence:', typeof window.mm?.midiToNoteSequence, '| midiToSequenceProto:', typeof window.mm?.midiToSequenceProto);
    },0);
  });
  </script>
</body>
</html>
