<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Visualizer â€“ Magenta Keyboard + MusicXML (no audio)</title>

  <!-- 1) Magenta (module import) -> guarantees window.mm exists -->
  <script type="module">
    import * as mmMod from 'https://cdn.jsdelivr.net/npm/@magenta/music@1.23.1/es6/core.js';
    window.mm = mmMod;
  </script>

  <!-- 2) OpenSheetMusicDisplay -->
  <script defer src="https://cdn.jsdelivr.net/npm/opensheetmusicdisplay@1.8.8/build/opensheetmusicdisplay.min.js"></script>

  <!-- 3) On-screen keyboard web component -->
  <script defer src="https://cdn.jsdelivr.net/gh/micahscopes/all-around-keyboard/dist/all-around-keyboard.min.js"></script>

  <style>
    :root { --c1:#2f6fab; --c2:#f5f7fb; --c3:#222; --c4:#d7dbe4; }
    * { box-sizing: border-box; }
    body{font-family:system-ui,Arial,sans-serif;background:var(--c2);color:var(--c3);margin:0;padding:24px}
    h1{margin:0 0 12px;color:var(--c1)}
    .card{background:#fff;border:1px solid var(--c4);border-radius:12px;padding:16px;max-width:1000px;margin:0 auto}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin:10px 0}
    label{font-size:.95rem}
    input[type="file"]{padding:4px 0}
    input[type="range"]{width:220px}
    button{padding:8px 12px;border-radius:8px;border:1px solid var(--c4);background:#fff;cursor:pointer}
    button:disabled{opacity:.6;cursor:not-allowed}
    #roll{width:100%;height:200px;border:1px solid var(--c4);border-radius:10px;background:#fff;margin:10px 0}
    all-around-keyboard{width:100%;height:170px;display:block;border:1px solid var(--c4);border-radius:10px}
    #osmd{background:#fff;border:1px solid var(--c4);border-radius:10px;padding:10px;margin-top:16px;overflow:auto}
    .small{font-size:.9rem;color:#555}
    #status{font:12px/1.4 ui-monospace,monospace;background:#fff;border:1px solid #e0e4ee;border-radius:8px;padding:8px;white-space:pre-wrap;max-height:140px;overflow:auto}
  </style>
</head>
<body>
  <h1>ðŸŽ¹ Visualizer â€“ Magenta Keyboard + Notation</h1>
  <div class="card">
    <div class="row">
      <label><strong>MIDI laden:</strong> <input id="midiFile" type="file" accept=".mid,.midi"></label>
      <label><strong>MusicXML laden:</strong> <input id="xmlFile" type="file" accept=".musicxml,.xml,.mxl"></label>
    </div>

    <div class="row">
      <button id="play" disabled>Play</button>
      <button id="stop" disabled>Stop</button>
      <label><input id="loop" type="checkbox"> Loop</label>
      <label><strong>Tempo:</strong> <span id="bpmVal">100</span> BPM</label>
      <input id="bpm" type="range" min="50" max="160" step="1" value="100">
    </div>

    <canvas id="roll"></canvas>
    <all-around-keyboard id="kb" octaves="2" width="900" depth="120"></all-around-keyboard>

    <div id="osmd"><p class="small">Lade eine MusicXML-Datei, um die Notenschrift zu sehen.</p></div>

    <h3>Status</h3>
    <div id="status"></div>
    <p class="small">Hinweis: Diese Seite spielt keinen Ton â€“ sie visualisiert nur (robust gegen Browser-Audio-Policies).</p>
  </div>

  <script>
  // ---------- helpers ----------
  const log = (...a)=>{ const el=document.getElementById('status'); el.textContent += a.join(' ') + '\n'; el.scrollTop=el.scrollHeight; };

  document.addEventListener('DOMContentLoaded', () => {
    // UI refs
    const midiInput = document.getElementById('midiFile');
    const xmlInput  = document.getElementById('xmlFile');
    const playBtn   = document.getElementById('play');
    const stopBtn   = document.getElementById('stop');
    const loopCb    = document.getElementById('loop');
    const bpm       = document.getElementById('bpm');
    const bpmVal    = document.getElementById('bpmVal');
    const kb        = document.getElementById('kb');
    const rollCv    = document.getElementById('roll');
    const ctx       = rollCv.getContext('2d');

    // Keyboard config
    const LOWEST_PITCH = 60; // C4
    const OCTAVES      = parseInt(kb.getAttribute('octaves')) || 2;
    const TOTAL_KEYS   = 12 * OCTAVES;
    const toIdx = p => p - LOWEST_PITCH;

    // Playback state (no audio)
    let seq = null;   // Magenta NoteSequence
    let notes = [];   // {p,s,e}
    let total = 0;    // seconds
    let playing = false;
    let startedAt = 0; // perf.now() seconds
    let t0 = 0;        // paused offset
    let rafId = null;
    let lastLit = new Set();

    // ----- Canvas roll -----
    function drawRoll(){
      const padding = 6;
      const W = rollCv.clientWidth, H = rollCv.clientHeight;
      if (rollCv.width !== W || rollCv.height !== H) { rollCv.width = W; rollCv.height = H; }
      ctx.clearRect(0,0,W,H);
      ctx.fillStyle = '#f3f5fb';
      ctx.fillRect(0,0,W,H);

      if (!notes.length || total <= 0) return;

      const secToX = s => padding + (W - 2*padding) * (s / total);
      const keyH   = (H - 2*padding) / TOTAL_KEYS;

      ctx.fillStyle = '#2f6fab';
      for (const n of notes) {
        const idx = toIdx(n.p);
        if (idx < 0 || idx >= TOTAL_KEYS) continue;
        const x = secToX(n.s), w = Math.max(2, secToX(n.e)-secToX(n.s));
        const y = H - padding - (idx+1)*keyH;
        ctx.fillRect(x, y, w, keyH - 1);
      }
    }

    function drawPlayhead(t){
      if (total <= 0) return;
      const padding = 6;
      const x = padding + (rollCv.width - 2*padding) * (Math.min(t,total) / total);
      ctx.strokeStyle = '#e74c3c';
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,rollCv.height); ctx.stroke();
    }

    // // ----- MIDI parsing -----
    // async function parseMidiBytes(uint8) {
    //   if (!window.mm) throw new Error('Magenta (mm) not loaded');
    //   const fn = mm.midiToNoteSequence || mm.midiToSequenceProto;
    //   if (!fn) throw new Error('No Magenta MIDI parser available');
    //   const seq = await Promise.resolve(fn(uint8)); // supports both sync/async variants
    //   return seq;
    // }

    // async function loadMidi(file){
    //   try{
    //     const buf  = await file.arrayBuffer();
    //     const ns   = await parseMidiBytes(new Uint8Array(buf));
    //     seq   = ns;
    //     notes = (ns.notes || []).map(n => ({ p:n.pitch, s:n.startTime, e:n.endTime }))
    //                              .sort((a,b)=>a.s-b.s);
    //     total = ns.totalTime || (notes.length ? Math.max(...notes.map(n=>n.e)) : 0);
    //     t0 = 0;
    //     drawRoll();
    //     dimAll();
    //     playBtn.disabled = false;
    //     stopBtn.disabled = false;
    //     log('MIDI geladen:', file.name, `| Noten: ${notes.length} | Dauer: ${total.toFixed(2)}s`);
    //   } catch(err){
    //     console.error(err); log('Fehler beim Laden der MIDI:', err.message || err);
    //     alert('MIDI konnte nicht geladen werden. (Ist es eine gÃ¼ltige .mid Datei?)');
    //   }
    // }
    
    // --- robust parser: try multiple Magenta APIs and show real errors ---
    async function parseMidiWithFallback(file) {
      if (!window.mm) throw new Error('Magenta (window.mm) ist nicht geladen.');

      const uint = new Uint8Array(await file.arrayBuffer());
      const tried = [];

      // 1) midiToNoteSequence (newer helper)
      if (typeof mm.midiToNoteSequence === 'function') {
        try { return await Promise.resolve(mm.midiToNoteSequence(uint)); }
        catch (e) { tried.push(`midiToNoteSequence: ${e?.message||e}`); }
      }

      // 2) midiToSequenceProto (older helper)
      if (typeof mm.midiToSequenceProto === 'function') {
        try { return await Promise.resolve(mm.midiToSequenceProto(uint)); }
        catch (e) { tried.push(`midiToSequenceProto: ${e?.message||e}`); }
      }

      // 3) urlToNoteSequence on a blob: works even when the above are missing
      if (typeof mm.urlToNoteSequence === 'function') {
        const url = URL.createObjectURL(new Blob([uint], { type: 'audio/midi' }));
        try { const ns = await mm.urlToNoteSequence(url); URL.revokeObjectURL(url); return ns; }
        catch (e) { tried.push(`urlToNoteSequence: ${e?.message||e}`); URL.revokeObjectURL(url); }
      }

      throw new Error('Konnte die MIDI nicht parsen. Versuche neu zu exportieren (Standard MIDI, Format 1). Details: ' + tried.join(' | '));
    }

    async function loadMidi(file){
      try {
        const ns = await parseMidiWithFallback(file);

        // normalize for your visuals
        seq   = ns;
        notes = (ns.notes || []).map(n => ({ p:n.pitch, s:n.startTime, e:n.endTime }))
                                .sort((a,b)=>a.s-b.s);
        total = ns.totalTime || (notes.length ? Math.max(...notes.map(n=>n.e)) : 0);
        t0 = 0;

        // refresh UI
        if (typeof dimAll === 'function') dimAll();
        if (typeof drawRoll === 'function') drawRoll();
        (window.playBtn || document.getElementById('play')).disabled = false;
        (window.stopBtn || document.getElementById('stop')).disabled = false;

        (window.log || console.log)('MIDI geladen:', file.name, `| Noten: ${notes.length} | Dauer: ${total.toFixed(2)}s`);
      } catch (err) {
        console.error(err);
        (window.log || console.log)('MIDI-Fehler:', err?.message || err);
        alert('MIDI konnte nicht geladen werden. Exportiere in MuseScore als â€žStandard MIDI (Format 1)â€œ und versuche es erneut.\n\n' +
              'Details: ' + (err?.message || err));
      }
    }


    // ----- MusicXML / OSMD -----
    let osmd = null;
    async function loadXML(file){
      try{
        if (!osmd) osmd = new opensheetmusicdisplay.OpenSheetMusicDisplay('osmd', { drawingParameters: 'compact' });
        const ext = file.name.toLowerCase().split('.').pop();
        if (ext === 'mxl') {
          const buf = await file.arrayBuffer();
          await osmd.load(buf);
        } else {
          const text = await file.text();
          await osmd.load(text);
        }
        await osmd.render();
        log('MusicXML geladen:', file.name);
      } catch(err){
        console.error(err); log('OSMD Fehler:', err.message || err);
        alert('Konnte die MusicXML-Datei nicht laden (braucht <score-partwise> / <score-timewise>).');
      }
    }

    // ----- Keyboard lighting -----
    function dimAll(){ kb.keysDim(Array.from({length: TOTAL_KEYS}, (_,i)=>i)); lastLit.clear(); }
    function updateLights(t){
      const active = new Set();
      for (const n of notes) {
        if (t >= n.s && t < n.e) {
          const idx = toIdx(n.p);
          if (idx >= 0 && idx < TOTAL_KEYS) active.add(idx);
        }
      }
      const toLight = [], toDim = [];
      for (const i of active)  if (!lastLit.has(i)) toLight.push(i);
      for (const i of lastLit) if (!active.has(i))  toDim.push(i);
      if (toLight.length) kb.keysLight(toLight);
      if (toDim.length)   kb.keysDim(toDim);
      lastLit = active;
    }

    // ----- Transport (RAF-based, tempo aware, loop) -----
    const baseBPM = 100;  // slider reference
    const getBPM  = () => Number(bpm.value);
    bpm.addEventListener('input', e => { bpmVal.textContent = e.target.value; });
    bpmVal.textContent = bpm.value;

    const nowTime = () => {
      if (!playing) return t0;
      const elapsed = (performance.now()/1000 - startedAt);
      const speed = getBPM() / baseBPM;
      return t0 + elapsed * speed;
    };

    function tick(){
      const t = nowTime();
      if (loopCb.checked && total > 0 && t >= total) {
        // wrap seamlessly
        t0 = 0;
        startedAt = performance.now()/1000;
      }
      drawRoll();
      drawPlayhead(Math.min(t,total));
      updateLights(Math.min(t,total));
      rafId = requestAnimationFrame(tick);
    }

    function start(){
      if (!notes.length || playing) return;
      playing = true;
      startedAt = performance.now()/1000;
      rafId = requestAnimationFrame(tick);
    }
    function stop(){
      playing = false;
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
      t0 = 0;
      dimAll();
      drawRoll();
    }

    // ----- File guards -----
    midiInput.addEventListener('change', e => {
      const f = e.target.files[0]; if (!f) return;
      const ext = f.name.toLowerCase().split('.').pop();
      if (ext === 'mid' || ext === 'midi') loadMidi(f);
      else alert('Bitte eine MIDI-Datei (.mid/.midi) wÃ¤hlen.');
    });
    xmlInput.addEventListener('change', e => {
      const f = e.target.files[0]; if (!f) return;
      const ext = f.name.toLowerCase().split('.').pop();
      if (ext === 'xml' || ext === 'musicxml' || ext === 'mxl') loadXML(f);
      else alert('Bitte eine MusicXML-Datei (.xml/.musicxml/.mxl) wÃ¤hlen.');
    });

    // ----- Controls -----
    playBtn.addEventListener('click', start);
    stopBtn.addEventListener('click', stop);

    // ----- Optional: tiny demo MIDI so page isn't empty -----
    (async () => {
      try {
        const demoURL = 'https://cdn.jsdelivr.net/gh/cifkao/html-midi-player@2b12128/twinkle_twinkle.mid';
        const resp = await fetch(demoURL);
        const ns   = await parseMidiBytes(new Uint8Array(await resp.arrayBuffer()));
        seq   = ns;
        notes = (ns.notes || []).map(n => ({ p:n.pitch, s:n.startTime, e:n.endTime }))
                                 .sort((a,b)=>a.s-b.s);
        total = ns.totalTime || (notes.length ? Math.max(...notes.map(n=>n.e)) : 0);
        drawRoll(); log('Demo MIDI geladen (Twinkle).');
        playBtn.disabled = false; stopBtn.disabled = false;
      } catch (e) {
        log('Demo MIDI konnte nicht geladen werden (offline/CDN blockiert).');
      }
    })();
  });
  </script>
</body>
</html>
